{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ElixirLS Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice. The Elixir Language Server (ElixirLS) provides a server that runs in the background, providing IDEs, editors, and other tools with information about Elixir Mix projects. It adheres to the LSP , a standard for frontend-independent IDE support. Debugger integration is accomplished through the similar VS Code Debug Protocol. These pages contain all the information needed to configure your favourite text editor or IDE and to work with the ElixirLS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected.","title":"Overview"},{"location":"#welcome-to-elixirls","text":"Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice. The Elixir Language Server (ElixirLS) provides a server that runs in the background, providing IDEs, editors, and other tools with information about Elixir Mix projects. It adheres to the LSP , a standard for frontend-independent IDE support. Debugger integration is accomplished through the similar VS Code Debug Protocol. These pages contain all the information needed to configure your favourite text editor or IDE and to work with the ElixirLS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected.","title":"Welcome to ElixirLS"},{"location":"features/","text":"Features Debugger support Automatic, incremental Dialyzer analysis Automatic inline suggestion of @specs based on Dialyzer's inferred success typings Inline reporting of build warnings and errors Documentation lookup on hover Go-to-definition Code completion Code formatter Find references to functions and modules (Thanks to @mattbaker) Quick symbol lookup in file (Thanks to @mattbaker) Quick symbol lookup in workspace and stdlib (both Elixir and erlang) (@lukaszsamson) Automatic builds and error reporting Builds are performed automatically when files are saved. If you want this to happen automatically when you type, you can turn on \"autosave\" in your IDE. Starting in Elixir 1.6, Mix compilers adhere to the Mix.Task.Compiler behaviour and return their error and warning diagnostics in a standardized way. Errors and warnings will be shown inline in your code as well as in the \"Problems\" pane in the IDE. If you're using an earlier version of Elixir, you'll need to look at the text log from the extension to see the errors and warnings. Dialyzer integration ElixirLS will automatically analyze your project with Dialyzer after each successful build. It maintains a \"manifest\" file in .elixir_ls/dialyzer_manifest that stores the results of the analysis. The initial analysis for a project can take a few minutes, but after that's completed, modules are re-analyzed only if necessary, so subsequent analyses are typically very fast -- often less than a second. It also looks at your modules' abstract code to determine whether they reference any modules that haven't been analyzed and includes them automatically. You can control which warnings are shown using the elixirLS.dialyzerWarnOpts setting in your project or IDE's settings.json . Find available options in Erlang docs at section \"Warning options\". To disable Dialyzer completely, set elixirLS.dialyzerEnabled to false. Check usage details in Dialyxir docs on GitHub and hexdocs . ElixirLS's Dialyzer integration uses internal, undocumented Dialyzer APIs, and so it won't be robust against changes to these APIs in future Erlang versions. Code completion ElixirLS bundles an advanced code completion provider. The provider builds on Elixir Sense library and utilizes two main mechanisms. The first one is reflection - getting information about compiled modules from Erlang and Elixir APIs. The second one is AST analysis of the current text buffer. While reflection gives precise results, it is not well suited for on demand completion of symbols from the currently edited file. The compiled version is likely to be outdated or the file may not compile at all. AST analysis helps in that case but it has its limitations. Unfortunately it is infeasible to be 100% accurate, especially with Elixir being a metaprogramming heavy language. The completions include: keywords special form snippets functions macros modules variables struct fields (only if the struct type is explicitly stated or can be inferred from the variable binding) atom map keys (if map keys can be inferred from variable binding) attributes types (in typespecs) behaviour callbacks (inside the body of implementing module) protocol functions (inside the body of implementing module) keys in keyword functions arguments (if defined in spec) function returns (if defined in spec) Workspace Symbols With Dialyzer integration enabled ElixirLS will build an index of symbols (modules, functions, types and callbacks). The symbols are taken from the current workspace, all dependencies and stdlib (Elixir and erlang). This feature enables quick navigation to symbol definitions.","title":"Features"},{"location":"features/#features","text":"Debugger support Automatic, incremental Dialyzer analysis Automatic inline suggestion of @specs based on Dialyzer's inferred success typings Inline reporting of build warnings and errors Documentation lookup on hover Go-to-definition Code completion Code formatter Find references to functions and modules (Thanks to @mattbaker) Quick symbol lookup in file (Thanks to @mattbaker) Quick symbol lookup in workspace and stdlib (both Elixir and erlang) (@lukaszsamson)","title":"Features"},{"location":"features/#automatic-builds-and-error-reporting","text":"Builds are performed automatically when files are saved. If you want this to happen automatically when you type, you can turn on \"autosave\" in your IDE. Starting in Elixir 1.6, Mix compilers adhere to the Mix.Task.Compiler behaviour and return their error and warning diagnostics in a standardized way. Errors and warnings will be shown inline in your code as well as in the \"Problems\" pane in the IDE. If you're using an earlier version of Elixir, you'll need to look at the text log from the extension to see the errors and warnings.","title":"Automatic builds and error reporting"},{"location":"features/#dialyzer-integration","text":"ElixirLS will automatically analyze your project with Dialyzer after each successful build. It maintains a \"manifest\" file in .elixir_ls/dialyzer_manifest that stores the results of the analysis. The initial analysis for a project can take a few minutes, but after that's completed, modules are re-analyzed only if necessary, so subsequent analyses are typically very fast -- often less than a second. It also looks at your modules' abstract code to determine whether they reference any modules that haven't been analyzed and includes them automatically. You can control which warnings are shown using the elixirLS.dialyzerWarnOpts setting in your project or IDE's settings.json . Find available options in Erlang docs at section \"Warning options\". To disable Dialyzer completely, set elixirLS.dialyzerEnabled to false. Check usage details in Dialyxir docs on GitHub and hexdocs . ElixirLS's Dialyzer integration uses internal, undocumented Dialyzer APIs, and so it won't be robust against changes to these APIs in future Erlang versions.","title":"Dialyzer integration"},{"location":"features/#code-completion","text":"ElixirLS bundles an advanced code completion provider. The provider builds on Elixir Sense library and utilizes two main mechanisms. The first one is reflection - getting information about compiled modules from Erlang and Elixir APIs. The second one is AST analysis of the current text buffer. While reflection gives precise results, it is not well suited for on demand completion of symbols from the currently edited file. The compiled version is likely to be outdated or the file may not compile at all. AST analysis helps in that case but it has its limitations. Unfortunately it is infeasible to be 100% accurate, especially with Elixir being a metaprogramming heavy language. The completions include: keywords special form snippets functions macros modules variables struct fields (only if the struct type is explicitly stated or can be inferred from the variable binding) atom map keys (if map keys can be inferred from variable binding) attributes types (in typespecs) behaviour callbacks (inside the body of implementing module) protocol functions (inside the body of implementing module) keys in keyword functions arguments (if defined in spec) function returns (if defined in spec)","title":"Code completion"},{"location":"features/#workspace-symbols","text":"With Dialyzer integration enabled ElixirLS will build an index of symbols (modules, functions, types and callbacks). The symbols are taken from the current workspace, all dependencies and stdlib (Elixir and erlang). This feature enables quick navigation to symbol definitions.","title":"Workspace Symbols"},{"location":"known-issues-limitations/","text":"Known Issues / Limitations .exs files don't return compilation errors \"Fetching n dependencies\" sometimes get stuck (remove the .elixir_ls directory to fix) Debugger doesn't work in Elixir 1.10.0 - 1.10.2 (but it should work in 1.10.3 when this fix is released) \"Go to definition\" does not work within the scope of a Phoenix router On-hover docs do not work with erlang modules or functions (better support of EEP-48 is needed) On first launch dialyzer will cause high CPU usage for a considerable time ElixirLS requires a workspace to be opened. Editing single-files is not supported #307","title":"Known issues and limitations"},{"location":"known-issues-limitations/#known-issues-limitations","text":".exs files don't return compilation errors \"Fetching n dependencies\" sometimes get stuck (remove the .elixir_ls directory to fix) Debugger doesn't work in Elixir 1.10.0 - 1.10.2 (but it should work in 1.10.3 when this fix is released) \"Go to definition\" does not work within the scope of a Phoenix router On-hover docs do not work with erlang modules or functions (better support of EEP-48 is needed) On first launch dialyzer will cause high CPU usage for a considerable time ElixirLS requires a workspace to be opened. Editing single-files is not supported #307","title":"Known Issues / Limitations"},{"location":"troubleshooting/","text":"Troubleshooting Basic troubleshooting steps: Restart your editor (which will restart ElixirLS) After stopping your editor, remove the entire .elixir_ls directory, then restart your editor NOTE: This will cause you to have to re-run the entire dialyzer build If your code doesn't compile in ElixirLS, it may be because ElixirLS compiles code with MIX_ENV=test (by default). So if you are missing some configuration in the test environment, your code may not compile. If you get an error like the following immediately on startup: [Warn - 1:56:04 PM] ** (exit) exited in: GenServer.call(ElixirLS.LanguageServer.JsonRpc, {:packet, %{...snip...}}, 5000) ** (EXIT) no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started and you installed Elixir and Erlang from the Erlang Solutions repository, you may not have a full installation of erlang. This can be solved with sudo apt-get install esl-erlang . Originally reported in #208 . On fedora if you only install the elixir package you will not have a full erlang installation, this can be fixed by running sudo dnf install erlang (reported in #231 ) If you are using Emacs with lsp-mode there's a possibility that you have set the wrong directory as the project root (especially if that directory does not have a mix.exs file). To fix that you should remove the project and re-initialize: https://github.com/elixir-lsp/elixir-ls/issues/364#issuecomment-829589139","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"Basic troubleshooting steps: Restart your editor (which will restart ElixirLS) After stopping your editor, remove the entire .elixir_ls directory, then restart your editor NOTE: This will cause you to have to re-run the entire dialyzer build If your code doesn't compile in ElixirLS, it may be because ElixirLS compiles code with MIX_ENV=test (by default). So if you are missing some configuration in the test environment, your code may not compile. If you get an error like the following immediately on startup: [Warn - 1:56:04 PM] ** (exit) exited in: GenServer.call(ElixirLS.LanguageServer.JsonRpc, {:packet, %{...snip...}}, 5000) ** (EXIT) no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started and you installed Elixir and Erlang from the Erlang Solutions repository, you may not have a full installation of erlang. This can be solved with sudo apt-get install esl-erlang . Originally reported in #208 . On fedora if you only install the elixir package you will not have a full erlang installation, this can be fixed by running sudo dnf install erlang (reported in #231 ) If you are using Emacs with lsp-mode there's a possibility that you have set the wrong directory as the project root (especially if that directory does not have a mix.exs file). To fix that you should remove the project and re-initialize: https://github.com/elixir-lsp/elixir-ls/issues/364#issuecomment-829589139","title":"Troubleshooting"},{"location":"getting-started/emacs/","text":"Emacs Setup Download the latest release: https://github.com/elixir-lsp/elixir-ls/releases/latest and unzip it into a directory (this is the directory referred to as the \"path-to-elixir-ls/release\" below) If using lsp-mode add this configuration: ( use-package lsp-mode :commands lsp :ensure t :diminish lsp-mode :hook ( elixir-mode . lsp ) :init ( add-to-list 'exec-path \"path-to-elixir-ls/release\" )) For eglot users: ( require 'eglot ) ;; This is optional. It automatically runs `M-x eglot` for you whenever you are in `elixir-mode` ( add-hook 'elixir-mode-hook 'eglot-ensure ) ;; Make sure to edit the path appropriately, use the .bat script instead for Windows ( add-to-list 'eglot-server-programs ' ( elixir-mode \"path-to-elixir-ls/release/language_server.sh\" )) The official lsp-mode package includes a client for the Elixir Language Server. Whenever opening a project for the first time, you will be prompted by emacs-lsp to select the correct project root. In that occasion, you also have the opportunity to blacklist projects. Information about projects is stored in a file pointed by the lsp-session-file variable. Its default location is ~/.emacs.d/.lsp-session-v1 . You may need to prune or amend this file if you change your mind about blacklisting a project or if you erroneously select a project root. For more information about the lsp-session-file and emacs-lsp in general, please refer to the official documentation . Remember that ElixirLS requires Erlang/OTP 22 and Elixir 1.10.0 or higher to run, so ensure that Erlang and Elixir are available in your PATH . This can be achieved, for example, by using the exec-path-from-shell Emacs package. Restarting the language server You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so: M-x lsp-workspace-restart Troubleshooting To be sure that you don't have outdated or incompatible packages installed, you may also want to rename your ~/.emacs.d directory while you are troubleshooting your ElixirLS Emacs setup. Also, ensure that Erlang, Elixir (i.e. erl , escript and friends) and the language_server.sh script are all available in your PATH . If they are not, you can try the following: ;; Ensure your Emacs environment looks like your user's shell one ( package-require 'exec-path-from-shell ) ( exec-path-from-shell-initialize ) Finally, to enable logging on the client-side, just: ( setq lsp-log-io t ) You can then follow the client logs for the current workspace by doing: M-x lsp-workspace-show-log Tips and Tricks Shortcuts for code lenses and quick actions You can run M-x lsp-avy-lens to show letters next to code lenses. You can then press those letters to trigger the respective action. If your sideline is enabled ( (setq lsp-ui-sideline-enable t) ), you can also use M-x lsp-execute-code-action to trigger quick-fix actions.","title":"Emacs"},{"location":"getting-started/emacs/#emacs","text":"","title":"Emacs"},{"location":"getting-started/emacs/#setup","text":"Download the latest release: https://github.com/elixir-lsp/elixir-ls/releases/latest and unzip it into a directory (this is the directory referred to as the \"path-to-elixir-ls/release\" below) If using lsp-mode add this configuration: ( use-package lsp-mode :commands lsp :ensure t :diminish lsp-mode :hook ( elixir-mode . lsp ) :init ( add-to-list 'exec-path \"path-to-elixir-ls/release\" )) For eglot users: ( require 'eglot ) ;; This is optional. It automatically runs `M-x eglot` for you whenever you are in `elixir-mode` ( add-hook 'elixir-mode-hook 'eglot-ensure ) ;; Make sure to edit the path appropriately, use the .bat script instead for Windows ( add-to-list 'eglot-server-programs ' ( elixir-mode \"path-to-elixir-ls/release/language_server.sh\" )) The official lsp-mode package includes a client for the Elixir Language Server. Whenever opening a project for the first time, you will be prompted by emacs-lsp to select the correct project root. In that occasion, you also have the opportunity to blacklist projects. Information about projects is stored in a file pointed by the lsp-session-file variable. Its default location is ~/.emacs.d/.lsp-session-v1 . You may need to prune or amend this file if you change your mind about blacklisting a project or if you erroneously select a project root. For more information about the lsp-session-file and emacs-lsp in general, please refer to the official documentation . Remember that ElixirLS requires Erlang/OTP 22 and Elixir 1.10.0 or higher to run, so ensure that Erlang and Elixir are available in your PATH . This can be achieved, for example, by using the exec-path-from-shell Emacs package.","title":"Setup"},{"location":"getting-started/emacs/#restarting-the-language-server","text":"You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so: M-x lsp-workspace-restart","title":"Restarting the language server"},{"location":"getting-started/emacs/#troubleshooting","text":"To be sure that you don't have outdated or incompatible packages installed, you may also want to rename your ~/.emacs.d directory while you are troubleshooting your ElixirLS Emacs setup. Also, ensure that Erlang, Elixir (i.e. erl , escript and friends) and the language_server.sh script are all available in your PATH . If they are not, you can try the following: ;; Ensure your Emacs environment looks like your user's shell one ( package-require 'exec-path-from-shell ) ( exec-path-from-shell-initialize ) Finally, to enable logging on the client-side, just: ( setq lsp-log-io t ) You can then follow the client logs for the current workspace by doing: M-x lsp-workspace-show-log","title":"Troubleshooting"},{"location":"getting-started/emacs/#tips-and-tricks","text":"","title":"Tips and Tricks"},{"location":"getting-started/emacs/#shortcuts-for-code-lenses-and-quick-actions","text":"You can run M-x lsp-avy-lens to show letters next to code lenses. You can then press those letters to trigger the respective action. If your sideline is enabled ( (setq lsp-ui-sideline-enable t) ), you can also use M-x lsp-execute-code-action to trigger quick-fix actions.","title":"Shortcuts for code lenses and quick actions"},{"location":"getting-started/kakoune/","text":"Kakoune Setup Install the kak-lsp client for the Kakoune editor. Limitations Encoding kak-lsp works only with UTF-8 documents. Position.character interpretation Currently, kak-lsp doesn't conform to the spec regarding the interpretation of Position.character . LSP spec says that A position inside a document (see Position definition below) is expressed as a zero-based line and character offset. The offsets are based on a UTF-16 string representation. So for a string of the form a\ud801\udc00b the character offset of the character a is 0, the character offset of \ud801\udc00 is 1 and the character offset of b is 3 since \ud801\udc00 is represented using two code units in UTF-16. However, kak-lsp treats Position.character as an offset in UTF-8 code points by default. Fortunately, it appears to produce the same result within the Basic Multilingual Plane (BMP) which includes a lot of characters. Unfortunately, many language servers violate the spec as well, and in an inconsistent manner. Please refer https://github.com/Microsoft/language-server-protocol/issues/376 for more information. There are two main types of violations we met in the wild: 1) Using UTF-8 code points, just like kak-lsp does. Those should work well with kak-lsp for characters outside BMP out of the box. 2) Using UTF-8 code units (bytes), just like Kakoune does. Those are supported by kak-lsp but require adding offset_encoding = \"utf-8\" to the language server configuration in kak-lsp.toml .","title":"Kakoune"},{"location":"getting-started/kakoune/#kakoune","text":"","title":"Kakoune"},{"location":"getting-started/kakoune/#setup","text":"Install the kak-lsp client for the Kakoune editor.","title":"Setup"},{"location":"getting-started/kakoune/#limitations","text":"","title":"Limitations"},{"location":"getting-started/kakoune/#encoding","text":"kak-lsp works only with UTF-8 documents.","title":"Encoding"},{"location":"getting-started/kakoune/#positioncharacter-interpretation","text":"Currently, kak-lsp doesn't conform to the spec regarding the interpretation of Position.character . LSP spec says that A position inside a document (see Position definition below) is expressed as a zero-based line and character offset. The offsets are based on a UTF-16 string representation. So for a string of the form a\ud801\udc00b the character offset of the character a is 0, the character offset of \ud801\udc00 is 1 and the character offset of b is 3 since \ud801\udc00 is represented using two code units in UTF-16. However, kak-lsp treats Position.character as an offset in UTF-8 code points by default. Fortunately, it appears to produce the same result within the Basic Multilingual Plane (BMP) which includes a lot of characters. Unfortunately, many language servers violate the spec as well, and in an inconsistent manner. Please refer https://github.com/Microsoft/language-server-protocol/issues/376 for more information. There are two main types of violations we met in the wild: 1) Using UTF-8 code points, just like kak-lsp does. Those should work well with kak-lsp for characters outside BMP out of the box. 2) Using UTF-8 code units (bytes), just like Kakoune does. Those are supported by kak-lsp but require adding offset_encoding = \"utf-8\" to the language server configuration in kak-lsp.toml .","title":"Position.character interpretation"},{"location":"getting-started/kate/","text":"Kate Setup Use the built-in LSP client for Kate.","title":"Kate"},{"location":"getting-started/kate/#kate","text":"","title":"Kate"},{"location":"getting-started/kate/#setup","text":"Use the built-in LSP client for Kate.","title":"Setup"},{"location":"getting-started/neovim/","text":"Setup There are several plugins available for NeoVim: Plugin Notes coc.nvim Does not support debugger nvim-dap Only debugger ALE Does not support debugger or typespec suggestions elixir-lsp/coc-elixir Does not support debugger vim-lsp Does not support debugger","title":"NeoVim"},{"location":"getting-started/neovim/#setup","text":"There are several plugins available for NeoVim: Plugin Notes coc.nvim Does not support debugger nvim-dap Only debugger ALE Does not support debugger or typespec suggestions elixir-lsp/coc-elixir Does not support debugger vim-lsp Does not support debugger","title":"Setup"},{"location":"getting-started/nova/","text":"Nova Setup Install the extension for Nova .","title":"Nova"},{"location":"getting-started/nova/#nova","text":"","title":"Nova"},{"location":"getting-started/nova/#setup","text":"Install the extension for Nova .","title":"Setup"},{"location":"getting-started/overview/","text":"Getting Started The Erlang LS language server works with all text editors and IDEs which adhere to the LSP protocol. The list of supported editors include Emacs , Vim , VS Code , Sublime Text 3 and more. These pages contain all the information needed to configure your favourite text editor or IDE to use ErlangLS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected. Emacs Kakoune Kate Neovim Nova Sublime Text 3 VS Code","title":"Overview"},{"location":"getting-started/overview/#getting-started","text":"The Erlang LS language server works with all text editors and IDEs which adhere to the LSP protocol. The list of supported editors include Emacs , Vim , VS Code , Sublime Text 3 and more. These pages contain all the information needed to configure your favourite text editor or IDE to use ErlangLS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected. Emacs Kakoune Kate Neovim Nova Sublime Text 3 VS Code","title":"Getting Started"},{"location":"getting-started/sublime/","text":"Sublime Setup Install the extension LSP-Elixir . Note that it does not have debugger support.","title":"Sublime"},{"location":"getting-started/sublime/#sublime","text":"","title":"Sublime"},{"location":"getting-started/sublime/#setup","text":"Install the extension LSP-Elixir . Note that it does not have debugger support.","title":"Setup"},{"location":"getting-started/vscode/","text":"Emacs Setup Install the official ElixirLS extension and enable it. Debugger ElixirLS includes debugger support adhering to the VS Code debugger protocol which is closely related to the Language Server Protocol. At the moment, only line breakpoints are supported. When debugging in Elixir or Erlang, only modules that have been \"interpreted\" (using :int.ni/1 or :int.i/1 ) will accept breakpoints or show up in stack traces. The debugger in ElixirLS automatically interprets all modules in the Mix project and dependencies prior to launching the Mix task, so you can set breakpoints anywhere in your project or dependency modules. In order to debug modules in .exs files (such as tests), they must be specified under requireFiles in your launch configuration so they can be loaded and interpreted prior to running the task. For example, the default launch configuration for \"mix test\" in the VS Code plugin looks like this: { \"type\" : \"mix_task\" , \"name\" : \"mix test\" , \"request\" : \"launch\" , \"task\" : \"test\" , \"taskArgs\" : [ \"--trace\" ], \"projectDir\" : \"${workspaceRoot}\" , \"requireFiles\" : [ \"test/**/test_helper.exs\" , \"test/**/*_test.exs\" ] } In order to debug a single test or a single test file it is currently necessary to modify taskArgs and make sure no other tests are required in requireFiles . { \"type\" : \"mix_task\" , \"name\" : \"mix test\" , \"request\" : \"launch\" , \"task\" : \"test\" , \"taskArgs\" : [ \"tests/some_test.exs:123\" ], \"projectDir\" : \"${workspaceRoot}\" , \"requireFiles\" : [ \"test/**/test_helper.exs\" , \"test/some_test.exs\" ] } Please note that due to :int limitation NIF modules cannot be interpreted and need to be excluded via excludeModules option. This option can be also used to disable interpreting for some modules when it is not desirable e.g. when performance is not satisfactory. { \"type\" : \"mix_task\" , \"name\" : \"mix test\" , \"request\" : \"launch\" , \"task\" : \"test\" , \"taskArgs\" : [ \"--trace\" ], \"projectDir\" : \"${workspaceRoot}\" , \"requireFiles\" : [ \"test/**/test_helper.exs\" , \"test/**/*_test.exs\" ], \"excludeModules\" : [ \":some_nif\" , \"Some.SlowModule\" ] }","title":"VSCode"},{"location":"getting-started/vscode/#emacs","text":"","title":"Emacs"},{"location":"getting-started/vscode/#setup","text":"Install the official ElixirLS extension and enable it.","title":"Setup"},{"location":"getting-started/vscode/#debugger","text":"ElixirLS includes debugger support adhering to the VS Code debugger protocol which is closely related to the Language Server Protocol. At the moment, only line breakpoints are supported. When debugging in Elixir or Erlang, only modules that have been \"interpreted\" (using :int.ni/1 or :int.i/1 ) will accept breakpoints or show up in stack traces. The debugger in ElixirLS automatically interprets all modules in the Mix project and dependencies prior to launching the Mix task, so you can set breakpoints anywhere in your project or dependency modules. In order to debug modules in .exs files (such as tests), they must be specified under requireFiles in your launch configuration so they can be loaded and interpreted prior to running the task. For example, the default launch configuration for \"mix test\" in the VS Code plugin looks like this: { \"type\" : \"mix_task\" , \"name\" : \"mix test\" , \"request\" : \"launch\" , \"task\" : \"test\" , \"taskArgs\" : [ \"--trace\" ], \"projectDir\" : \"${workspaceRoot}\" , \"requireFiles\" : [ \"test/**/test_helper.exs\" , \"test/**/*_test.exs\" ] } In order to debug a single test or a single test file it is currently necessary to modify taskArgs and make sure no other tests are required in requireFiles . { \"type\" : \"mix_task\" , \"name\" : \"mix test\" , \"request\" : \"launch\" , \"task\" : \"test\" , \"taskArgs\" : [ \"tests/some_test.exs:123\" ], \"projectDir\" : \"${workspaceRoot}\" , \"requireFiles\" : [ \"test/**/test_helper.exs\" , \"test/some_test.exs\" ] } Please note that due to :int limitation NIF modules cannot be interpreted and need to be excluded via excludeModules option. This option can be also used to disable interpreting for some modules when it is not desirable e.g. when performance is not satisfactory. { \"type\" : \"mix_task\" , \"name\" : \"mix test\" , \"request\" : \"launch\" , \"task\" : \"test\" , \"taskArgs\" : [ \"--trace\" ], \"projectDir\" : \"${workspaceRoot}\" , \"requireFiles\" : [ \"test/**/test_helper.exs\" , \"test/**/*_test.exs\" ], \"excludeModules\" : [ \":some_nif\" , \"Some.SlowModule\" ] }","title":"Debugger"}]}